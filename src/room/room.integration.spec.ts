import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { INestApplication } from '@nestjs/common';
import { DataSource } from 'typeorm';

import configurations from 'src/config/configurations';
import { UserService } from 'src/user/user.service';
import { UserModule } from 'src/user/user.module';
import { TestUtils } from 'src/test/test-utils';
import { JwtPayload } from 'src/auth/strategies/jwt.payload';
import { UserType } from 'src/user/user.meta';

import { RoomController } from './room.controller';
import { RoomService } from './room.service';
import { RoomModule } from './room.module';
import { CreateRoomDto } from './dto/create-room.dto';
import { RoomStatus } from './entities/room.meta';
import { CreateSettlementDto } from './dto/create-settlement.dto';
import { RoomWithUsersDto } from './dto/room-user-with-nickname.dto';

describe('RoomModule - Integration Test', () => {
  let app: INestApplication;

  let roomController: RoomController;
  let roomService: RoomService;
  let userService: UserService;
  let testUtils: TestUtils;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [
        ConfigModule.forRoot({
          load: [configurations],
          isGlobal: true,
          envFilePath: ['.env'],
        }),
        TypeOrmModule.forRootAsync({
          imports: [ConfigModule],
          inject: [ConfigService],
          useFactory: (configService: ConfigService) => {
            const dbConfig = configService.get('database');
            return dbConfig;
          },
        }),
        RoomModule,
        UserModule,
      ],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    roomController = moduleFixture.get<RoomController>(RoomController);
    roomService = moduleFixture.get<RoomService>(RoomService);
    userService = moduleFixture.get<UserService>(UserService);
  });

  beforeEach(async () => {
    const dataSource = app.get(DataSource);
    await dataSource.synchronize(true);
    testUtils = new TestUtils();
    await testUtils.initializeTestUsers(userService);
    await userService.createNickname(
      testUtils.getTestUser().uuid,
      'ÌñâÎ≥µÌïú_ÏàòÏÜå_1234',
    );
  });

  afterEach(async () => {
    const dataSource = app.get(DataSource);
    await dataSource.synchronize(true);
  });

  afterAll(async () => {
    await app.close();
  });

  it('should be defined', () => {
    expect(roomController).toBeDefined();
    expect(roomService).toBeDefined();
  });

  describe('create', () => {
    it('should create a room', async () => {
      const dto: CreateRoomDto = {
        description: 'Ï∫êÎ¶¨Ïñ¥ Îëê Í∞ú ÏûàÏäµÎãàÎã§',
        title: 'ÏßÄÍ≥°ÌöåÍ¥Ä Ìè¨Ìï≠Ïó≠ Ïπ¥ÌíÄÌï¥Ïöî~ üòé',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24),
        departureLocation: 'ÏßÄÍ≥°ÌöåÍ¥Ä',
        destinationLocation: 'Ìè¨Ìï≠Ïó≠',
        maxParticipant: 4,
      };
      const result = await roomController.create(
        testUtils.getTestUserJwtToken(),
        dto,
      );
      expect(result).not.toBeNull();
      if (!result) {
        throw new Error('Room creation failed');
      }
      expect(result instanceof RoomWithUsersDto).toBe(true);
      expect(result.title).toBe(dto.title);
      expect(result.departureTime).toEqual(dto.departureTime);
      expect(result.departureLocation).toBe(dto.departureLocation);
      expect(result.destinationLocation).toBe(dto.destinationLocation);
      expect(result.maxParticipant).toBe(dto.maxParticipant);
      expect(result.currentParticipant).toBe(1);
      expect(result.status).toBe(RoomStatus.ACTIVATED);
      expect(result.description).toBe(dto.description);
    });
  });

  describe('settlement', () => {
    it('should create a requested settlement with an account number', async () => {
      const room = await roomService.create(testUtils.getTestUser().uuid, {
        description: 'Ï∫êÎ¶¨Ïñ¥ Îëê Í∞ú ÏûàÏäµÎãàÎã§',
        title: 'ÏßÄÍ≥°ÌöåÍ¥Ä Ìè¨Ìï≠Ïó≠ Ïπ¥ÌíÄÌï¥Ïöî~ üòé',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24),
        departureLocation: 'ÏßÄÍ≥°ÌöåÍ¥Ä',
        destinationLocation: 'Ìè¨Ìï≠Ïó≠',
        maxParticipant: 4,
      });

      expect(room).not.toBeNull();
      if (!room) {
        throw new Error('Room creation failed');
      }

      const dto: CreateSettlementDto = {
        payAmount: 10000,
        payerAccountNumber: '123-456-7890-1234',
        payerAccountHolderName: 'Ìè¨ÎãâÏä§',
        payerBankName: 'ÎÜçÌòë',
        updateAccount: true,
      };
      const settlement = await roomService.requestSettlement(
        room.uuid,
        testUtils.getTestUser().uuid,
        dto,
      );
      expect(settlement).not.toBeNull();
      if (!settlement) {
        throw new Error('Settlement creation failed');
      }
      expect(settlement.payAmount).toBe(dto.payAmount);

      // Í≥ÑÏ¢åÎ≤àÌò∏ Î≥µÌò∏Ìôî Í≤ÄÏ¶ù
      const account = await userService.getAccount(
        testUtils.getTestUser().uuid,
      );
      expect(account).not.toBeNull();
      if (!account) {
        throw new Error('Account retrieval failed');
      }
      expect(account.accountNumber).toBe(dto.payerAccountNumber);
      expect(account.accountHolderName).toBe(dto.payerAccountHolderName);
      expect(account.bankName).toBe(dto.payerBankName);
    });
  });

  describe('update', () => {
    let testRoom: any;
    let testUserJwt: JwtPayload;

    beforeEach(async () => {
      // Create a test room
      testRoom = await roomService.create(testUtils.getTestUser().uuid, {
        description: 'Ï∫êÎ¶¨Ïñ¥ Îëê Í∞ú ÏûàÏäµÎãàÎã§',
        title: 'ÏßÄÍ≥°ÌöåÍ¥Ä Ìè¨Ìï≠Ïó≠ Ïπ¥ÌíÄÌï¥Ïöî~ üòé',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24),
        departureLocation: 'ÏßÄÍ≥°ÌöåÍ¥Ä',
        destinationLocation: 'Ìè¨Ìï≠Ïó≠',
        maxParticipant: 4,
      });

      testUserJwt = testUtils.getTestUserJwtToken();
    });

    it('should successfully update room information', async () => {
      const updateDto = {
        title: 'ÏàòÏ†ïÎêú Î∞© Ï†úÎ™©',
        description: 'ÏàòÏ†ïÎêú ÏÑ§Î™Ö',
        maxParticipant: 6,
      };

      const result = await roomController.update(
        testRoom.uuid,
        testUserJwt,
        updateDto,
      );

      expect(result).toBeDefined();
      expect(result.title).toBe(updateDto.title);
      expect(result.description).toBe(updateDto.description);
      expect(result.maxParticipant).toBe(updateDto.maxParticipant);
      expect(result.departureLocation).toBe(testRoom.departureLocation); // Î∞îÎÄåÏßÄ ÏïäÏùå
      expect(result.destinationLocation).toBe(testRoom.destinationLocation); // Î∞îÎÄåÏßÄ ÏïäÏùå

      const updateDto2 = {
        title: 'Îã§Ï§ë ÏàòÏ†ï Ï†úÎ™©',
        description: 'Îã§Ï§ë ÏàòÏ†ï ÏÑ§Î™Ö',
        maxParticipant: 8,
        departureLocation: 'ÏàòÏ†ïÎêú Ï∂úÎ∞úÏßÄ',
        destinationLocation: 'ÏàòÏ†ïÎêú ÎèÑÏ∞©ÏßÄ',
      };

      const result2 = await roomController.update(
        testRoom.uuid,
        testUserJwt,
        updateDto2,
      );

      expect(result2.title).toBe(updateDto2.title);
      expect(result2.description).toBe(updateDto2.description);
      expect(result2.maxParticipant).toBe(updateDto2.maxParticipant);
      expect(result2.departureLocation).toBe(updateDto2.departureLocation);
      expect(result2.destinationLocation).toBe(updateDto2.destinationLocation);
    });

    it('should update departure time and reset departure alert', async () => {
      const newDepartureTime = new Date(Date.now() + 1000 * 60 * 60 * 48); // 48ÏãúÍ∞Ñ Îí§
      const updateDto = {
        departureTime: newDepartureTime,
      };

      const result = await roomController.update(
        testRoom.uuid,
        testUserJwt,
        updateDto,
      );

      expect(result).toBeDefined();
      expect(result.departureTime.getTime()).toBe(newDepartureTime.getTime());
      expect(result.departureAlertSent).toBe(false); // Ï∂úÎ∞ú ÏïåÎ¶º Ï¥àÍ∏∞Ìôî
    });

    it('should update only provided fields', async () => {
      const updateDto = {
        title: 'Î∂ÄÎ∂Ñ ÏàòÏ†ïÎêú Ï†úÎ™©',
      };

      const result = await roomController.update(
        testRoom.uuid,
        testUserJwt,
        updateDto,
      );

      expect(result).toBeDefined();
      expect(result.title).toBe(updateDto.title);
      expect(result.description).toBe(testRoom.description); // Î∞îÎÄåÏßÄ ÏïäÏùå
      expect(result.maxParticipant).toBe(testRoom.maxParticipant); // Î∞îÎÄåÏßÄ ÏïäÏùå
      expect(result.departureLocation).toBe(testRoom.departureLocation); // Î∞îÎÄåÏßÄ ÏïäÏùå
    });

    it('should throw BadRequestException when departure time is in the past', async () => {
      const pastTime = new Date(Date.now() - 1000 * 60 * 60); // 1ÏãúÍ∞Ñ Ï†Ñ
      const updateDto = {
        departureTime: pastTime,
      };

      await expect(
        roomController.update(testRoom.uuid, testUserJwt, updateDto),
      ).rejects.toThrow('Ï∂úÎ∞ú ÏãúÍ∞ÑÏùÄ ÌòÑÏû¨ ÏãúÍ∞ÑÎ≥¥Îã§ Ïù¥Ï†ÑÏùº Ïàò ÏóÜÏäµÎãàÎã§.');
    });

    it('should throw NotFoundException when room does not exist', async () => {
      const nonExistentUuid = '123e4567-e89b-12d3-a456-426614174000';
      const updateDto = {
        title: 'ÏàòÏ†ïÎêú Ï†úÎ™©',
      };

      await expect(
        roomController.update(nonExistentUuid, testUserJwt, updateDto),
        // TODO: ÏóêÎü¨ Î©îÏÑ∏ÏßÄ constantsÎ°ú ÎπºÎäî Í≤É Í≥†ÎØº
      ).rejects.toThrow('Î∞©Ïù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
    });

    it('should throw UnauthorizedException when user is not the owner or admin', async () => {
      // Îã§Î•∏ Ïú†Ï†Ä ÏÉùÏÑ±
      const anotherUser = await userService.save({
        email: 'another@test.com',
        password: 'password123',
        name: 'Another User',
        userType: UserType.student,
      });

      const anotherUserJwt: JwtPayload = {
        uuid: anotherUser.uuid,
        email: anotherUser.email,
        name: anotherUser.name,
        nickname: 'another_user',
        userType: UserType.student,
      };

      const updateDto = {
        title: 'ÏàòÏ†ïÎêú Ï†úÎ™©',
      };

      await expect(
        roomController.update(testRoom.uuid, anotherUserJwt, updateDto),
      ).rejects.toThrow('Î∞©Ïû• ÎòêÎäî Í¥ÄÎ¶¨ÏûêÍ∞Ä ÏïÑÎãôÎãàÎã§.');
    });

    it('should allow admin to update any room', async () => {
      const adminJwt: JwtPayload = {
        uuid: 'admin-uuid',
        email: 'admin@test.com',
        name: 'Admin User',
        nickname: 'admin',
        userType: UserType.admin,
      };

      const updateDto = {
        title: 'Í¥ÄÎ¶¨ÏûêÍ∞Ä ÏàòÏ†ïÌïú Ï†úÎ™©',
      };

      const result = await roomController.update(
        testRoom.uuid,
        adminJwt,
        updateDto,
      );

      expect(result).toBeDefined();
      expect(result.title).toBe(updateDto.title);
    });

    it('should throw BadRequestException when the room is completed', async () => {
      // Î®ºÏ†Ä Ï†ïÏÇ∞ ÏöîÏ≤≠ÏùÑ ÌÜµÌï¥ Î∞©ÏùÑ Ï†ïÏÇ∞ ÏÉÅÌÉúÎ°ú ÎßåÎì¶
      await roomService.requestSettlement(
        testRoom.uuid,
        testUtils.getTestUser().uuid,
        {
          payAmount: 10000,
          payerAccountNumber: '123-456-7890-1234',
          payerAccountHolderName: 'Ìè¨ÎãâÏä§',
          payerBankName: 'ÎÜçÌòë',
          updateAccount: true,
        },
      );

      // Í∑∏ ÌõÑ Î∞©ÏùÑ ÏôÑÎ£å
      await roomService.completeRoom(
        testRoom.uuid,
        testUtils.getTestUser().uuid,
        UserType.student,
      );

      const updateDto = {
        title: 'ÏàòÏ†ïÎêú Ï†úÎ™©',
      };

      await expect(
        roomController.update(testRoom.uuid, testUserJwt, updateDto),
      ).rejects.toThrow('Ïù¥ÎØ∏ Ï¢ÖÎ£åÎêú Î∞©ÏûÖÎãàÎã§.');
    });

    it('should throw BadRequestException when the room is deleted', async () => {
      // Î®ºÏ†Ä Î∞©ÏùÑ ÏÇ≠Ï†ú
      await roomService.remove(testRoom.uuid, testUtils.getTestUser().uuid);

      const updateDto = {
        title: 'ÏàòÏ†ïÎêú Ï†úÎ™©',
      };

      await expect(
        roomController.update(testRoom.uuid, testUserJwt, updateDto),
      ).rejects.toThrow('Ïù¥ÎØ∏ Ï¢ÖÎ£åÎêú Î∞©ÏûÖÎãàÎã§.');
    });
  });
});
