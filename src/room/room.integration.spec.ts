import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { INestApplication } from '@nestjs/common';
import { DataSource } from 'typeorm';

import configurations from 'src/config/configurations';
import { UserService } from 'src/user/user.service';
import { UserModule } from 'src/user/user.module';
import { TestUtils } from 'src/test/test-utils';
import { JwtPayload } from 'src/auth/strategies/jwt.payload';
import { UserType } from 'src/user/user.meta';
import { FcmService } from 'src/fcm/fcm.service';

import { RoomController } from './room.controller';
import { RoomService } from './room.service';
import { RoomModule } from './room.module';
import { CreateRoomDto } from './dto/create-room.dto';
import { RoomStatus } from './entities/room.meta';
import { CreateSettlementDto } from './dto/create-settlement.dto';
import { RoomWithUsersDto } from './dto/room-user-with-nickname.dto';

describe('RoomModule - Integration Test', () => {
  let app: INestApplication;

  let roomController: RoomController;
  let roomService: RoomService;
  let userService: UserService;
  let testUtils: TestUtils;
  let fcmService: FcmService;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [
        ConfigModule.forRoot({
          load: [configurations],
          isGlobal: true,
          envFilePath: ['.env.test'],
        }),
        TypeOrmModule.forRootAsync({
          imports: [ConfigModule],
          inject: [ConfigService],
          useFactory: (configService: ConfigService) => {
            const dbConfig = configService.get('database');
            return dbConfig;
          },
        }),
        RoomModule,
        UserModule,
      ],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    roomController = moduleFixture.get<RoomController>(RoomController);
    roomService = moduleFixture.get<RoomService>(RoomService);
    userService = moduleFixture.get<UserService>(UserService);
    fcmService = moduleFixture.get<FcmService>(FcmService);
  });

  beforeEach(async () => {
    const dataSource = app.get(DataSource);
    await dataSource.synchronize(true);
    testUtils = new TestUtils();
    await testUtils.initializeTestUsers(userService);
    await userService.createNickname(
      testUtils.getTestUser().uuid,
      'ÌñâÎ≥µÌïú_ÏàòÏÜå_1234',
    );
    await userService.createNickname(
      testUtils.getTestAdmin().uuid,
      'Í¥ÄÎ¶¨Ïûê_ÎãâÎÑ§ÏûÑ_5678',
    );

    // sendPushNotificationByUserUuid Î™®ÌÇπ
    if (fcmService) {
      jest
        .spyOn(fcmService, 'sendPushNotificationByUserUuid')
        .mockResolvedValue({
          successCount: 1,
          failureCount: 0,
          responses: [],
        });
    }
  });

  afterEach(async () => {
    const dataSource = app.get(DataSource);
    await dataSource.synchronize(true);
  });

  afterAll(async () => {
    await app.close();
  });

  it('should be defined', () => {
    expect(roomController).toBeDefined();
    expect(roomService).toBeDefined();
  });

  describe('create', () => {
    it('should create a room', async () => {
      const dto: CreateRoomDto = {
        description: 'Ï∫êÎ¶¨Ïñ¥ Îëê Í∞ú ÏûàÏäµÎãàÎã§',
        title: 'ÏßÄÍ≥°ÌöåÍ¥Ä Ìè¨Ìï≠Ïó≠ Ïπ¥ÌíÄÌï¥Ïöî~ üòé',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24),
        departureLocation: 'ÏßÄÍ≥°ÌöåÍ¥Ä',
        destinationLocation: 'Ìè¨Ìï≠Ïó≠',
        maxParticipant: 4,
      };
      const result = await roomController.create(
        testUtils.getTestUserJwtToken(),
        dto,
      );
      expect(result).not.toBeNull();
      if (!result) {
        throw new Error('Room creation failed');
      }
      expect(result instanceof RoomWithUsersDto).toBe(true);
      expect(result.title).toBe(dto.title);
      expect(result.departureTime).toEqual(dto.departureTime);
      expect(result.departureLocation).toBe(dto.departureLocation);
      expect(result.destinationLocation).toBe(dto.destinationLocation);
      expect(result.maxParticipant).toBe(dto.maxParticipant);
      expect(result.currentParticipant).toBe(1);
      expect(result.status).toBe(RoomStatus.ACTIVATED);
      expect(result.description).toBe(dto.description);
    });
  });

  describe('settlement', () => {
    it('should create a requested settlement with an account number', async () => {
      const room = await roomService.create(testUtils.getTestUser().uuid, {
        description: 'Ï∫êÎ¶¨Ïñ¥ Îëê Í∞ú ÏûàÏäµÎãàÎã§',
        title: 'ÏßÄÍ≥°ÌöåÍ¥Ä Ìè¨Ìï≠Ïó≠ Ïπ¥ÌíÄÌï¥Ïöî~ üòé',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24),
        departureLocation: 'ÏßÄÍ≥°ÌöåÍ¥Ä',
        destinationLocation: 'Ìè¨Ìï≠Ïó≠',
        maxParticipant: 4,
      });

      expect(room).not.toBeNull();
      if (!room) {
        throw new Error('Room creation failed');
      }

      const dto: CreateSettlementDto = {
        payAmount: 10000,
        payerAccountNumber: '123-456-7890-1234',
        payerAccountHolderName: 'Ìè¨ÎãâÏä§',
        payerBankName: 'ÎÜçÌòë',
        updateAccount: true,
      };
      const settlement = await roomService.requestSettlement(
        room.uuid,
        testUtils.getTestUser().uuid,
        dto,
      );
      expect(settlement).not.toBeNull();
      if (!settlement) {
        throw new Error('Settlement creation failed');
      }
      expect(settlement.payAmount).toBe(dto.payAmount);

      // Í≥ÑÏ¢åÎ≤àÌò∏ Î≥µÌò∏Ìôî Í≤ÄÏ¶ù
      const account = await userService.getAccount(
        testUtils.getTestUser().uuid,
      );
      expect(account).not.toBeNull();
      if (!account) {
        throw new Error('Account retrieval failed');
      }
      expect(account.accountNumber).toBe(dto.payerAccountNumber);
      expect(account.accountHolderName).toBe(dto.payerAccountHolderName);
      expect(account.bankName).toBe(dto.payerBankName);
    });
  });

  describe('update', () => {
    let testRoom: any;
    let testUserJwt: JwtPayload;

    beforeEach(async () => {
      // Create a test room
      testRoom = await roomService.create(testUtils.getTestUser().uuid, {
        description: 'Ï∫êÎ¶¨Ïñ¥ Îëê Í∞ú ÏûàÏäµÎãàÎã§',
        title: 'ÏßÄÍ≥°ÌöåÍ¥Ä Ìè¨Ìï≠Ïó≠ Ïπ¥ÌíÄÌï¥Ïöî~ üòé',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24),
        departureLocation: 'ÏßÄÍ≥°ÌöåÍ¥Ä',
        destinationLocation: 'Ìè¨Ìï≠Ïó≠',
        maxParticipant: 4,
      });

      testUserJwt = testUtils.getTestUserJwtToken();
    });

    it('should successfully update room information', async () => {
      const updateDto = {
        title: 'ÏàòÏ†ïÎêú Î∞© Ï†úÎ™©',
        description: 'ÏàòÏ†ïÎêú ÏÑ§Î™Ö',
        maxParticipant: 6,
      };

      const result = await roomController.update(
        testRoom.uuid,
        testUserJwt,
        updateDto,
      );

      expect(result).toBeDefined();
      expect(result.title).toBe(updateDto.title);
      expect(result.description).toBe(updateDto.description);
      expect(result.maxParticipant).toBe(updateDto.maxParticipant);
      expect(result.departureLocation).toBe(testRoom.departureLocation); // Î∞îÎÄåÏßÄ ÏïäÏùå
      expect(result.destinationLocation).toBe(testRoom.destinationLocation); // Î∞îÎÄåÏßÄ ÏïäÏùå

      const updateDto2 = {
        title: 'Îã§Ï§ë ÏàòÏ†ï Ï†úÎ™©',
        description: 'Îã§Ï§ë ÏàòÏ†ï ÏÑ§Î™Ö',
        maxParticipant: 8,
        departureLocation: 'ÏàòÏ†ïÎêú Ï∂úÎ∞úÏßÄ',
        destinationLocation: 'ÏàòÏ†ïÎêú ÎèÑÏ∞©ÏßÄ',
      };

      const result2 = await roomController.update(
        testRoom.uuid,
        testUserJwt,
        updateDto2,
      );

      expect(result2.title).toBe(updateDto2.title);
      expect(result2.description).toBe(updateDto2.description);
      expect(result2.maxParticipant).toBe(updateDto2.maxParticipant);
      expect(result2.departureLocation).toBe(updateDto2.departureLocation);
      expect(result2.destinationLocation).toBe(updateDto2.destinationLocation);
    });

    it('should update departure time and reset departure alert', async () => {
      const newDepartureTime = new Date(Date.now() + 1000 * 60 * 60 * 48); // 48ÏãúÍ∞Ñ Îí§
      const updateDto = {
        departureTime: newDepartureTime,
      };

      const result = await roomController.update(
        testRoom.uuid,
        testUserJwt,
        updateDto,
      );

      expect(result).toBeDefined();
      expect(result.departureTime.getTime()).toBe(newDepartureTime.getTime());
      expect(result.departureAlertSent).toBe(false); // Ï∂úÎ∞ú ÏïåÎ¶º Ï¥àÍ∏∞Ìôî
    });

    it('should update only provided fields', async () => {
      const updateDto = {
        title: 'Î∂ÄÎ∂Ñ ÏàòÏ†ïÎêú Ï†úÎ™©',
      };

      const result = await roomController.update(
        testRoom.uuid,
        testUserJwt,
        updateDto,
      );

      expect(result).toBeDefined();
      expect(result.title).toBe(updateDto.title);
      expect(result.description).toBe(testRoom.description); // Î∞îÎÄåÏßÄ ÏïäÏùå
      expect(result.maxParticipant).toBe(testRoom.maxParticipant); // Î∞îÎÄåÏßÄ ÏïäÏùå
      expect(result.departureLocation).toBe(testRoom.departureLocation); // Î∞îÎÄåÏßÄ ÏïäÏùå
    });

    it('should throw BadRequestException when departure time is in the past', async () => {
      const pastTime = new Date(Date.now() - 1000 * 60 * 60); // 1ÏãúÍ∞Ñ Ï†Ñ
      const updateDto = {
        departureTime: pastTime,
      };

      await expect(
        roomController.update(testRoom.uuid, testUserJwt, updateDto),
      ).rejects.toThrow('Ï∂úÎ∞ú ÏãúÍ∞ÑÏùÄ ÌòÑÏû¨ ÏãúÍ∞ÑÎ≥¥Îã§ Ïù¥Ï†ÑÏùº Ïàò ÏóÜÏäµÎãàÎã§.');
    });

    it('should throw NotFoundException when room does not exist', async () => {
      const nonExistentUuid = '123e4567-e89b-12d3-a456-426614174000';
      const updateDto = {
        title: 'ÏàòÏ†ïÎêú Ï†úÎ™©',
      };

      await expect(
        roomController.update(nonExistentUuid, testUserJwt, updateDto),
        // TODO: ÏóêÎü¨ Î©îÏÑ∏ÏßÄ constantsÎ°ú ÎπºÎäî Í≤É Í≥†ÎØº
      ).rejects.toThrow('Î∞©Ïù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
    });

    it('should throw UnauthorizedException when user is not the owner or admin', async () => {
      // Îã§Î•∏ Ïú†Ï†Ä ÏÉùÏÑ±
      const anotherUser = await userService.save({
        email: 'another@test.com',
        password: 'password123',
        name: 'Another User',
        userType: UserType.student,
      });

      const anotherUserJwt: JwtPayload = {
        uuid: anotherUser.uuid,
        email: anotherUser.email,
        name: anotherUser.name,
        nickname: 'another_user',
        userType: UserType.student,
      };

      const updateDto = {
        title: 'ÏàòÏ†ïÎêú Ï†úÎ™©',
      };

      await expect(
        roomController.update(testRoom.uuid, anotherUserJwt, updateDto),
      ).rejects.toThrow('Î∞©Ïû• ÎòêÎäî Í¥ÄÎ¶¨ÏûêÍ∞Ä ÏïÑÎãôÎãàÎã§.');
    });

    it('should allow admin to update any room', async () => {
      const adminJwt: JwtPayload = {
        uuid: 'admin-uuid',
        email: 'admin@test.com',
        name: 'Admin User',
        nickname: 'admin',
        userType: UserType.admin,
      };

      const updateDto = {
        title: 'Í¥ÄÎ¶¨ÏûêÍ∞Ä ÏàòÏ†ïÌïú Ï†úÎ™©',
      };

      const result = await roomController.update(
        testRoom.uuid,
        adminJwt,
        updateDto,
      );

      expect(result).toBeDefined();
      expect(result.title).toBe(updateDto.title);
    });

    it('should throw BadRequestException when the room is completed', async () => {
      // Î®ºÏ†Ä Ï†ïÏÇ∞ ÏöîÏ≤≠ÏùÑ ÌÜµÌï¥ Î∞©ÏùÑ Ï†ïÏÇ∞ ÏÉÅÌÉúÎ°ú ÎßåÎì¶
      await roomService.requestSettlement(
        testRoom.uuid,
        testUtils.getTestUser().uuid,
        {
          payAmount: 10000,
          payerAccountNumber: '123-456-7890-1234',
          payerAccountHolderName: 'Ìè¨ÎãâÏä§',
          payerBankName: 'ÎÜçÌòë',
          updateAccount: true,
        },
      );

      // Í∑∏ ÌõÑ Î∞©ÏùÑ ÏôÑÎ£å
      await roomService.completeRoom(
        testRoom.uuid,
        testUtils.getTestUser().uuid,
        UserType.student,
      );

      const updateDto = {
        title: 'ÏàòÏ†ïÎêú Ï†úÎ™©',
      };

      await expect(
        roomController.update(testRoom.uuid, testUserJwt, updateDto),
      ).rejects.toThrow('Ïù¥ÎØ∏ Ï¢ÖÎ£åÎêú Î∞©ÏûÖÎãàÎã§.');
    });

    it('should throw BadRequestException when the room is deleted', async () => {
      // Î®ºÏ†Ä Î∞©ÏùÑ ÏÇ≠Ï†ú
      await roomService.remove(testRoom.uuid, testUtils.getTestUser().uuid);

      const updateDto = {
        title: 'ÏàòÏ†ïÎêú Ï†úÎ™©',
      };

      await expect(
        roomController.update(testRoom.uuid, testUserJwt, updateDto),
      ).rejects.toThrow('Ïù¥ÎØ∏ Ï¢ÖÎ£åÎêú Î∞©ÏûÖÎãàÎã§.');
    });
  });

  describe('cancelKickUserFromRoom', () => {
    let testRoom: any;
    let kickedUser: any;
    let testUserJwt: JwtPayload;

    beforeEach(async () => {
      testRoom = await roomService.create(testUtils.getTestUser().uuid, {
        description: 'ÌÖåÏä§Ìä∏ Î∞©ÏûÖÎãàÎã§',
        title: 'ÌÖåÏä§Ìä∏ Î∞©',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24),
        departureLocation: 'Ï∂úÎ∞úÏßÄ',
        destinationLocation: 'ÎèÑÏ∞©ÏßÄ',
        maxParticipant: 4,
      });

      // Í∞ïÌá¥Ìï† Ïú†Ï†Ä ÏÉùÏÑ±
      kickedUser = await userService.save({
        email: 'kicked@test.com',
        password: 'password123',
        name: 'Kicked User',
        userType: UserType.student,
      });

      await userService.createNickname(kickedUser.uuid, 'Í∞ïÌá¥Îêú_Ïú†Ï†Ä_1234');

      // Î∞©Ïóê Ï∞∏Ïó¨ÏãúÌÇ® ÌõÑ Í∞ïÌá¥
      await roomService.joinRoom(testRoom.uuid, kickedUser.uuid);
      await roomService.kickUserFromRoom(
        testRoom.uuid,
        testUtils.getTestUser().uuid,
        kickedUser.uuid,
        'ÌÖåÏä§Ìä∏ Í∞ïÌá¥',
        UserType.student,
      );

      testUserJwt = {
        uuid: testUtils.getTestUser().uuid,
        email: testUtils.getTestUser().email,
        name: testUtils.getTestUser().name,
        nickname: 'ÌñâÎ≥µÌïú_ÏàòÏÜå_1234',
        userType: UserType.student,
      };
    });

    it('should cancel kick user from room successfully', async () => {
      const result = await roomService.cancelKickUserFromRoom(
        testRoom.uuid,
        testUtils.getTestUser().uuid,
        kickedUser.uuid,
        UserType.student,
      );

      expect(result).toBeDefined();
      expect(result.uuid).toBe(testRoom.uuid);

      // Í∞ïÌá¥Îêú ÏÇ¨Ïö©ÏûêÍ∞Ä Î∞©Ïóê Îã§Ïãú Ï∞∏Ïó¨Ìï† Ïàò ÏûàÎäîÏßÄ ÌôïÏù∏
      const joinResult = await roomService.joinRoom(
        testRoom.uuid,
        kickedUser.uuid,
      );
      expect(joinResult.room.uuid).toBe(testRoom.uuid);
    });

    it('should throw NotFoundException when kicked user does not exist', async () => {
      const nonExistentUserUuid = '123e4567-e89b-12d3-a456-426614174000';

      await expect(
        roomService.cancelKickUserFromRoom(
          testRoom.uuid,
          testUtils.getTestUser().uuid,
          nonExistentUserUuid,
          UserType.student,
        ),
      ).rejects.toThrow('Í∞ïÌá¥Îêú ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
    });

    it('should throw UnauthorizedException when user is not the owner or admin', async () => {
      // Îã§Î•∏ Ïú†Ï†Ä ÏÉùÏÑ±
      const anotherUser = await userService.save({
        email: 'another@test.com',
        password: 'password123',
        name: 'Another User',
        userType: UserType.student,
      });

      await expect(
        roomService.cancelKickUserFromRoom(
          testRoom.uuid,
          anotherUser.uuid,
          kickedUser.uuid,
          UserType.student,
        ),
      ).rejects.toThrow('Î∞©Ïû• ÎòêÎäî Í¥ÄÎ¶¨ÏûêÎßå Í∞ïÌá¥Î•º Ï∑®ÏÜåÌï† Ïàò ÏûàÏäµÎãàÎã§.');
    });

    it('should allow admin to cancel kick any user', async () => {
      const adminJwt: JwtPayload = {
        uuid: 'admin-uuid',
        email: 'admin@test.com',
        name: 'Admin User',
        nickname: 'admin',
        userType: UserType.admin,
      };

      const result = await roomService.cancelKickUserFromRoom(
        testRoom.uuid,
        adminJwt.uuid,
        kickedUser.uuid,
        UserType.admin,
      );

      expect(result).toBeDefined();
      expect(result.uuid).toBe(testRoom.uuid);

      // Î∞© Ïû¨ÏûÖÏû•
      const joinResult = await roomService.joinRoom(
        testRoom.uuid,
        kickedUser.uuid,
      );
      expect(joinResult.room.uuid).toBe(testRoom.uuid);
    });

    it('should work through controller', async () => {
      const result = await roomController.cancelKickUserFromRoom(
        testUserJwt,
        testRoom.uuid,
        { kickedUserUuid: kickedUser.uuid },
      );

      expect(result).toBeDefined();
      expect(result.uuid).toBe(testRoom.uuid);

      // Î∞© Ïû¨ÏûÖÏû•
      const joinResult = await roomService.joinRoom(
        testRoom.uuid,
        kickedUser.uuid,
      );
      expect(joinResult.room.uuid).toBe(testRoom.uuid);
    });
  });

  describe('statistics', () => {
    it('should return monthly statistics with status and location dictionaries', async () => {
      const now = new Date();
      const y = now.getFullYear();
      const m = now.getMonth() + 1;
      const mStr = m.toString().padStart(2, '0');

      // ÌòÑÏû¨ ÏõîÏùò ÎßàÏßÄÎßâ ÎÇ† Í≥ÑÏÇ∞
      const lastDay = new Date(y, m, 0).getDate();

      const startDate = `${y}-${mStr}-01`;
      const endDate = `${y}-${mStr}-${lastDay}`;

      // Room A (ACTIVE)
      await roomService.create(testUtils.getTestUser().uuid, {
        description: 'A desc',
        title: 'A Ï†úÎ™©',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24 * 1),
        departureLocation: 'ÌïôÏÉùÌöåÍ¥Ä',
        destinationLocation: 'Ìè¨Ìï≠Ïó≠',
        maxParticipant: 4,
      });

      // Room B (IN_SETTLEMENT)
      const roomB = await roomService.create(testUtils.getTestUser().uuid, {
        description: 'B desc',
        title: 'B Ï†úÎ™©',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24 * 2),
        departureLocation: 'ÏßÄÍ≥°ÌöåÍ¥Ä',
        destinationLocation: 'Ìè¨Ìï≠Ïó≠',
        maxParticipant: 4,
      });
      await roomService.requestSettlement(
        roomB.uuid,
        testUtils.getTestUser().uuid,
        {
          payAmount: 1000,
          payerAccountNumber: '111-222',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'Íµ≠ÎØº',
          updateAccount: true,
        },
      );

      // Room C (COMPLETED)
      const roomC = await roomService.create(testUtils.getTestUser().uuid, {
        description: 'C desc',
        title: 'C Ï†úÎ™©',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24 * 3),
        departureLocation: 'ÌïôÏÉùÌöåÍ¥Ä',
        destinationLocation: 'ÏßÄÍ≥°ÌöåÍ¥Ä',
        maxParticipant: 4,
      });
      await roomService.requestSettlement(
        roomC.uuid,
        testUtils.getTestUser().uuid,
        {
          payAmount: 2000,
          payerAccountNumber: '333-444',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'ÎÜçÌòë',
          updateAccount: true,
        },
      );
      await roomService.completeRoom(
        roomC.uuid,
        testUtils.getTestUser().uuid,
        UserType.student,
      );

      // Room D (DELETED)
      const roomD = await roomService.create(testUtils.getTestUser().uuid, {
        description: 'D desc',
        title: 'D Ï†úÎ™©',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24 * 4),
        departureLocation: 'Ìè¨Ìï≠Ïó≠',
        destinationLocation: 'ÌïôÏÉùÌöåÍ¥Ä',
        maxParticipant: 4,
      });
      await roomService.remove(roomD.uuid, testUtils.getTestUser().uuid);

      const res = await roomController.getRoomStatistics({
        startDate,
        endDate,
      });
      expect(res).toBeDefined();

      // ÌòÑÏû¨ ÏõîÏùÑ Í∏∞Ï§ÄÏúºÎ°ú monthKey ÏÉùÏÑ± (Îëê ÏûêÎ¶¨ Ïõî ÌòïÏãùÏúºÎ°ú)
      const monthKey = `${y}-${mStr}`;

      const monthData = res.data[monthKey];
      expect(monthData).toBeDefined();
      if (!monthData) {
        throw new Error(
          `Month data not found for key: ${monthKey}. Available keys: ${Object.keys(res.data).join(', ')}`,
        );
      }

      // statusCounts dictionary
      expect(monthData.statusCounts).toBeDefined();
      expect(typeof monthData.statusCounts.total).toBe('number');
      expect(monthData.statusCounts.total).toBeGreaterThanOrEqual(4);
      // ACTIVEÎäî Ï¥ù 1Í∞ú (A)
      expect(
        monthData.statusCounts[RoomStatus.ACTIVATED],
      ).toBeGreaterThanOrEqual(1);
      // IN_SETTLEMENTÎäî Ï¥ù 1Í∞ú (B)
      expect(
        monthData.statusCounts[RoomStatus.IN_SETTLEMENT],
      ).toBeGreaterThanOrEqual(1);
      // COMPLETEDÎäî Ï¥ù 1Í∞ú (C)
      expect(
        monthData.statusCounts[RoomStatus.COMPLETED],
      ).toBeGreaterThanOrEqual(1);
      // DELETEDÎäî Ï¥ù 1Í∞ú (D)
      expect(monthData.statusCounts[RoomStatus.DELETED]).toBeGreaterThanOrEqual(
        1,
      );

      // locations dictionary
      expect(monthData.departureLocationCounts).toBeDefined();
      expect(monthData.destinationLocationCounts).toBeDefined();
      // ÌÇ§-Í∞í ÌòïÌÉú Í≤ÄÏ¶ù
      expect(typeof monthData.departureLocationCounts).toBe('object');
      expect(typeof monthData.destinationLocationCounts).toBe('object');
      // Ï¥ùÌï© Í≤ÄÏ¶ù
      expect(monthData.departureLocationCounts.total).toBe(
        monthData.statusCounts.total,
      );
      expect(monthData.destinationLocationCounts.total).toBe(
        monthData.statusCounts.total,
      );
    });
  });

  describe('settlement', () => {
    let testRoom: any;
    let testUser: any;

    beforeEach(async () => {
      testUser = testUtils.getTestUser();
      testRoom = await roomService.create(testUser.uuid, {
        description: 'Test room for settlement',
        title: 'Ï†ïÏÇ∞ ÌÖåÏä§Ìä∏ Î∞©',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24 * 1),
        departureLocation: 'ÌïôÏÉùÌöåÍ¥Ä',
        destinationLocation: 'Ìè¨Ìï≠Ïó≠',
        maxParticipant: 4,
      });
    });

    describe('requestSettlement', () => {
      it('should request settlement successfully', async () => {
        const settlementDto = {
          payAmount: 10000,
          payerAccountNumber: '123-456-789',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
          updateAccount: true,
        };

        const result = await roomService.requestSettlement(
          testRoom.uuid,
          testUser.uuid,
          settlementDto,
        );

        expect(result).toBeDefined();
        expect(result.roomUuid).toBe(testRoom.uuid);
        expect(result.payerNickname).toBe('ÌñâÎ≥µÌïú_ÏàòÏÜå_1234');
        expect(result.payAmount).toBe(10000);
        expect(result.payerAccountHolderName).toBe('ÌÖåÏä§ÌÑ∞');
        expect(result.payerBankName).toBe('Íµ≠ÎØºÏùÄÌñâ');
        expect(result.payAmountPerPerson).toBe(10000); // 1Î™ÖÏù¥ÎØÄÎ°ú Ï†ÑÏ≤¥ Í∏àÏï°
      });

      it('should throw BadRequestException when room is already in settlement', async () => {
        const settlementDto = {
          payAmount: 10000,
          payerAccountNumber: '123-456-789',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
          updateAccount: true,
        };

        // Ï≤´ Î≤àÏß∏ Ï†ïÏÇ∞ ÏöîÏ≤≠
        await roomService.requestSettlement(
          testRoom.uuid,
          testUser.uuid,
          settlementDto,
        );

        // Îëê Î≤àÏß∏ Ï†ïÏÇ∞ ÏöîÏ≤≠ ÏãúÎèÑ
        await expect(
          roomService.requestSettlement(
            testRoom.uuid,
            testUser.uuid,
            settlementDto,
          ),
        ).rejects.toThrow('Ïù¥ÎØ∏ Ï†ïÏÇ∞Ïù¥ ÏßÑÌñâÎêòÍ≥† ÏûàÏäµÎãàÎã§.');
      });

      it('should throw BadRequestException when room is deleted', async () => {
        // Î∞© ÏÇ≠Ï†ú
        await roomService.remove(testRoom.uuid, testUser.uuid);

        const settlementDto = {
          payAmount: 10000,
          payerAccountNumber: '123-456-789',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
          updateAccount: true,
        };

        await expect(
          roomService.requestSettlement(
            testRoom.uuid,
            testUser.uuid,
            settlementDto,
          ),
        ).rejects.toThrow('ÏÇ≠Ï†úÎêú Î∞©ÏûÖÎãàÎã§.');
      });

      it('should throw BadRequestException when room is completed', async () => {
        const settlementDto = {
          payAmount: 10000,
          payerAccountNumber: '123-456-789',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
          updateAccount: true,
        };

        // Ï†ïÏÇ∞ ÏöîÏ≤≠
        await roomService.requestSettlement(
          testRoom.uuid,
          testUser.uuid,
          settlementDto,
        );

        // Î∞© ÏôÑÎ£å
        await roomService.completeRoom(
          testRoom.uuid,
          testUser.uuid,
          UserType.student,
        );

        // ÏôÑÎ£åÎêú Î∞©Ïóê Ï†ïÏÇ∞ ÏöîÏ≤≠ ÏãúÎèÑ
        await expect(
          roomService.requestSettlement(
            testRoom.uuid,
            testUser.uuid,
            settlementDto,
          ),
        ).rejects.toThrow('Ï†ïÏÇ∞Ïù¥ Ï¢ÖÎ£åÎêú Î∞©ÏûÖÎãàÎã§.');
      });
    });

    describe('updateSettlement', () => {
      beforeEach(async () => {
        const settlementDto = {
          payAmount: 10000,
          payerAccountNumber: '123-456-789',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
          updateAccount: true,
        };

        await roomService.requestSettlement(
          testRoom.uuid,
          testUser.uuid,
          settlementDto,
        );
      });

      it('should update settlement successfully', async () => {
        const updateDto = {
          payAmount: 15000,
          payerAccountNumber: '987-654-321',
          payerAccountHolderName: 'ÏàòÏ†ïÎêúÌÖåÏä§ÌÑ∞',
          payerBankName: 'Ïã†ÌïúÏùÄÌñâ',
          updateAccount: true,
        };

        const result = await roomService.updateSettlement(
          testRoom.uuid,
          testUser.uuid,
          updateDto,
        );

        expect(result).toBeDefined();
        expect(result.payAmount).toBe(15000);
        expect(result.payerAccountHolderName).toBe('ÏàòÏ†ïÎêúÌÖåÏä§ÌÑ∞');
        expect(result.payerBankName).toBe('Ïã†ÌïúÏùÄÌñâ');
        expect(result.payAmountPerPerson).toBe(15000);
      });

      it('should throw BadRequestException when room is not in settlement', async () => {
        // Ï†ïÏÇ∞ Ï∑®ÏÜå
        await roomService.cancelSettlement(testRoom.uuid, testUser.uuid);

        const updateDto = {
          payAmount: 15000,
          payerAccountNumber: '987-654-321',
          payerAccountHolderName: 'ÏàòÏ†ïÎêúÌÖåÏä§ÌÑ∞',
          payerBankName: 'Ïã†ÌïúÏùÄÌñâ',
          updateAccount: true,
        };

        await expect(
          roomService.updateSettlement(testRoom.uuid, testUser.uuid, updateDto),
        ).rejects.toThrow('Ï†ïÏÇ∞Ïù¥ ÏßÑÌñâÎêòÍ≥† ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
      });

      it('should throw UnauthorizedException when user is not the payer', async () => {
        const otherUser = testUtils.getTestAdmin();

        const updateDto = {
          payAmount: 15000,
          payerAccountNumber: '987-654-321',
          payerAccountHolderName: 'ÏàòÏ†ïÎêúÌÖåÏä§ÌÑ∞',
          payerBankName: 'Ïã†ÌïúÏùÄÌñâ',
          updateAccount: true,
        };

        await expect(
          roomService.updateSettlement(
            testRoom.uuid,
            otherUser.uuid,
            updateDto,
          ),
        ).rejects.toThrow('Ï†ïÏÇ∞ÏûêÍ∞Ä ÏïÑÎãàÎØÄÎ°ú Ï†ïÏÇ∞ Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï† Ïàò ÏóÜÏäµÎãàÎã§.');
      });
    });

    describe('cancelSettlement', () => {
      beforeEach(async () => {
        const settlementDto = {
          payAmount: 10000,
          payerAccountNumber: '123-456-789',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
          updateAccount: true,
        };

        await roomService.requestSettlement(
          testRoom.uuid,
          testUser.uuid,
          settlementDto,
        );
      });

      it('should cancel settlement successfully', async () => {
        const result = await roomService.cancelSettlement(
          testRoom.uuid,
          testUser.uuid,
        );

        expect(result).toBeDefined();
        expect(result!.status).toBe(RoomStatus.ACTIVATED);
        expect(result!.payerUuid).toBeNull();
        expect(result!.payAmount).toBeNull();
      });

      it('should throw BadRequestException when room is not in settlement', async () => {
        // Ï†ïÏÇ∞ Ï∑®ÏÜå
        await roomService.cancelSettlement(testRoom.uuid, testUser.uuid);

        // Ïù¥ÎØ∏ Ï∑®ÏÜåÎêú Ï†ïÏÇ∞ÏùÑ Îã§Ïãú Ï∑®ÏÜå ÏãúÎèÑ
        await expect(
          roomService.cancelSettlement(testRoom.uuid, testUser.uuid),
        ).rejects.toThrow('Ï†ïÏÇ∞Ïù¥ ÏßÑÌñâÎêòÍ≥† ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
      });

      it('should throw UnauthorizedException when user is not the payer', async () => {
        const otherUser = testUtils.getTestAdmin();

        await expect(
          roomService.cancelSettlement(testRoom.uuid, otherUser.uuid),
        ).rejects.toThrow('Ï†ïÏÇ∞ÏûêÍ∞Ä ÏïÑÎãàÎØÄÎ°ú Ï†ïÏÇ∞ ÏöîÏ≤≠ÏùÑ Ï∑®ÏÜåÌï† Ïàò ÏóÜÏäµÎãàÎã§.');
      });
    });

    describe('getSettlement', () => {
      beforeEach(async () => {
        const settlementDto = {
          payAmount: 10000,
          payerAccountNumber: '123-456-789',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
          updateAccount: true,
        };

        await roomService.requestSettlement(
          testRoom.uuid,
          testUser.uuid,
          settlementDto,
        );
      });

      it('should get settlement information successfully', async () => {
        const result = await roomService.getSettlement(testRoom.uuid);

        expect(result).toBeDefined();
        expect(result.roomUuid).toBe(testRoom.uuid);
        expect(result.payerNickname).toBe('ÌñâÎ≥µÌïú_ÏàòÏÜå_1234');
        expect(result.payAmount).toBe(10000);
        expect(result.payerAccountHolderName).toBe('ÌÖåÏä§ÌÑ∞');
        expect(result.payerBankName).toBe('Íµ≠ÎØºÏùÄÌñâ');
        expect(result.payAmountPerPerson).toBe(10000);
      });

      it('should throw BadRequestException when room is not in settlement', async () => {
        // Ï†ïÏÇ∞ Ï∑®ÏÜå
        await roomService.cancelSettlement(testRoom.uuid, testUser.uuid);

        await expect(roomService.getSettlement(testRoom.uuid)).rejects.toThrow(
          'Ï†ïÏÇ∞Ïù¥ ÏßÑÌñâÎêòÍ≥† ÏûàÏßÄ ÏïäÏäµÎãàÎã§.',
        );
      });

      it('should throw NotFoundException when room does not exist', async () => {
        const nonExistentUuid = '123e4567-e89b-12d3-a456-426614174000';

        await expect(
          roomService.getSettlement(nonExistentUuid),
        ).rejects.toThrow('Î∞©Ïù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
      });
    });

    describe('updateRoomUserIsPaid', () => {
      it('should throw BadRequestException when room is not in settlement', async () => {
        const otherUser = testUtils.getTestAdmin();

        await expect(
          roomService.updateRoomUserIsPaid(testRoom.uuid, otherUser.uuid, true),
        ).rejects.toThrow('Ï†ïÏÇ∞Ïù¥ ÏßÑÌñâÎêòÍ≥† ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
      });

      it('should throw BadRequestException when user is not in room', async () => {
        const otherUser = testUtils.getTestAdmin();

        const settlementDto = {
          payAmount: 10000,
          payerAccountNumber: '123-456-789',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
          updateAccount: true,
        };

        await roomService.requestSettlement(
          testRoom.uuid,
          testUser.uuid,
          settlementDto,
        );

        await expect(
          roomService.updateRoomUserIsPaid(testRoom.uuid, otherUser.uuid, true),
        ).rejects.toThrow('Î∞©Ïóê Í∞ÄÏûÖÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
      });
    });

    describe('completeRoom', () => {
      beforeEach(async () => {
        const settlementDto = {
          payAmount: 10000,
          payerAccountNumber: '123-456-789',
          payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
          payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
          updateAccount: true,
        };

        await roomService.requestSettlement(
          testRoom.uuid,
          testUser.uuid,
          settlementDto,
        );
      });

      it('should complete room successfully', async () => {
        const result = await roomService.completeRoom(
          testRoom.uuid,
          testUser.uuid,
          UserType.student,
        );

        expect(result).toBeDefined();
        expect(result!.status).toBe(RoomStatus.COMPLETED);
      });

      it('should throw BadRequestException when room is already completed', async () => {
        // Î∞© ÏôÑÎ£å
        await roomService.completeRoom(
          testRoom.uuid,
          testUser.uuid,
          UserType.student,
        );

        // Ïù¥ÎØ∏ ÏôÑÎ£åÎêú Î∞©ÏùÑ Îã§Ïãú ÏôÑÎ£å ÏãúÎèÑ
        await expect(
          roomService.completeRoom(
            testRoom.uuid,
            testUser.uuid,
            UserType.student,
          ),
        ).rejects.toThrow('Ïù¥ÎØ∏ Ï¢ÖÎ£åÎêú Î∞©ÏûÖÎãàÎã§.');
      });

      it('should throw UnauthorizedException when user is not the payer or admin', async () => {
        const otherUser = testUtils.getTestAdmin();

        await expect(
          roomService.completeRoom(
            testRoom.uuid,
            otherUser.uuid,
            UserType.student,
          ),
        ).rejects.toThrow('Ï†ïÏÇ∞Ïûê ÎòêÎäî Í¥ÄÎ¶¨ÏûêÍ∞Ä ÏïÑÎãôÎãàÎã§.');
      });

      it('should allow admin to complete room', async () => {
        const adminUser = testUtils.getTestAdmin();

        const result = await roomService.completeRoom(
          testRoom.uuid,
          adminUser.uuid,
          UserType.admin,
        );

        expect(result).toBeDefined();
        expect(result!.status).toBe(RoomStatus.COMPLETED);
      });
    });
  });

  describe('joinRoom - settlement condition', () => {
    let testRoom: any;
    let testUser: any;
    let otherUser: any;

    beforeEach(async () => {
      testUser = testUtils.getTestUser();
      otherUser = testUtils.getTestAdmin();

      testRoom = await roomService.create(testUser.uuid, {
        description: 'Test room for join',
        title: 'Ï∞∏Ïó¨ ÌÖåÏä§Ìä∏ Î∞©',
        departureTime: new Date(Date.now() + 1000 * 60 * 60 * 24 * 1),
        departureLocation: 'ÌïôÏÉùÌöåÍ¥Ä',
        destinationLocation: 'Ìè¨Ìï≠Ïó≠',
        maxParticipant: 4,
      });
    });

    it('should join room successfully when room is activated', async () => {
      const result = await roomService.joinRoom(testRoom.uuid, otherUser.uuid);

      expect(result).toBeDefined();
      expect(result.sendMessage).toBe(true);
      expect(result.room.uuid).toBe(testRoom.uuid);
      expect(result.room.room_users).toHaveLength(2); // Î∞©Ïû• + Ï∞∏Ïó¨Ìïú ÏÇ¨Ïö©Ïûê
    });

    it('should throw BadRequestException when trying to join room in settlement', async () => {
      // Ï†ïÏÇ∞ ÏöîÏ≤≠
      const settlementDto = {
        payAmount: 10000,
        payerAccountNumber: '123-456-789',
        payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
        payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
        updateAccount: true,
      };

      await roomService.requestSettlement(
        testRoom.uuid,
        testUser.uuid,
        settlementDto,
      );

      const newUser = await userService.save({
        email: 'new@test.com',
        password: 'password123',
        name: 'New User',
        userType: UserType.student,
      });
      await userService.createNickname(newUser.uuid, 'ÏÉàÎ°úÏö¥_Ïú†Ï†Ä_1234');
      // Ï†ïÏÇ∞ Ï§ëÏù∏ Î∞©Ïóê Ï∞∏Ïó¨ ÏãúÎèÑ
      await expect(
        roomService.joinRoom(testRoom.uuid, newUser.uuid),
      ).rejects.toThrow('Ï†ïÏÇ∞Ïù¥ ÏßÑÌñâÎêòÍ≥† ÏûàÏñ¥ Ï∞∏Ïó¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
    });

    it('should throw BadRequestException when trying to join completed room', async () => {
      // Ï†ïÏÇ∞ ÏöîÏ≤≠
      const settlementDto = {
        payAmount: 10000,
        payerAccountNumber: '123-456-789',
        payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
        payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
        updateAccount: true,
      };

      await roomService.requestSettlement(
        testRoom.uuid,
        testUser.uuid,
        settlementDto,
      );

      // Î∞© ÏôÑÎ£å
      await roomService.completeRoom(
        testRoom.uuid,
        testUser.uuid,
        UserType.student,
      );

      const newUser = await userService.save({
        email: 'new@test.com',
        password: 'password123',
        name: 'New User',
        userType: UserType.student,
      });
      await userService.createNickname(newUser.uuid, 'ÏÉàÎ°úÏö¥_Ïú†Ï†Ä_1234');
      // ÏôÑÎ£åÎêú Î∞©Ïóê Ï∞∏Ïó¨ ÏãúÎèÑ
      await expect(
        roomService.joinRoom(testRoom.uuid, newUser.uuid),
      ).rejects.toThrow('Ï†ïÏÇ∞Ïù¥ ÏßÑÌñâÎêòÍ≥† ÏûàÏñ¥ Ï∞∏Ïó¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
    });

    it('should allow re-joining for existing room users even when room is in settlement', async () => {
      // Î®ºÏ†Ä Î∞©Ïóê Ï∞∏Ïó¨
      await roomService.joinRoom(testRoom.uuid, otherUser.uuid);

      // Ï†ïÏÇ∞ ÏöîÏ≤≠
      const settlementDto = {
        payAmount: 10000,
        payerAccountNumber: '123-456-789',
        payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
        payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
        updateAccount: true,
      };

      await roomService.requestSettlement(
        testRoom.uuid,
        testUser.uuid,
        settlementDto,
      );

      // Ïù¥ÎØ∏ Ï∞∏Ïó¨Ìïú ÏÇ¨Ïö©ÏûêÍ∞Ä Îã§Ïãú Ï∞∏Ïó¨ ÏãúÎèÑ
      const result = await roomService.joinRoom(testRoom.uuid, otherUser.uuid);

      expect(result).toBeDefined();
      expect(result.sendMessage).toBe(false); // Ïù¥ÎØ∏ Ï∞∏Ïó¨Ìïú ÏÇ¨Ïö©ÏûêÏù¥ÎØÄÎ°ú Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏïàÌï®
      expect(result.room.uuid).toBe(testRoom.uuid);
    });

    it('should allow re-joining for existing room users even when room is completed', async () => {
      // Î®ºÏ†Ä Î∞©Ïóê Ï∞∏Ïó¨
      await roomService.joinRoom(testRoom.uuid, otherUser.uuid);

      // Ï†ïÏÇ∞ ÏöîÏ≤≠
      const settlementDto = {
        payAmount: 10000,
        payerAccountNumber: '123-456-789',
        payerAccountHolderName: 'ÌÖåÏä§ÌÑ∞',
        payerBankName: 'Íµ≠ÎØºÏùÄÌñâ',
        updateAccount: true,
      };

      await roomService.requestSettlement(
        testRoom.uuid,
        testUser.uuid,
        settlementDto,
      );

      // Î∞© ÏôÑÎ£å
      await roomService.completeRoom(
        testRoom.uuid,
        testUser.uuid,
        UserType.student,
      );

      // Ïù¥ÎØ∏ Ï∞∏Ïó¨Ìïú ÏÇ¨Ïö©ÏûêÍ∞Ä Îã§Ïãú Ï∞∏Ïó¨ ÏãúÎèÑ
      const result = await roomService.joinRoom(testRoom.uuid, otherUser.uuid);

      expect(result).toBeDefined();
      expect(result.sendMessage).toBe(false); // Ïù¥ÎØ∏ Ï∞∏Ïó¨Ìïú ÏÇ¨Ïö©ÏûêÏù¥ÎØÄÎ°ú Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏïàÌï®
      expect(result.room.uuid).toBe(testRoom.uuid);
    });
  });
});
